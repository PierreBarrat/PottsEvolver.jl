var documenterSearchIndex = {"docs":
[{"location":"sampling/#Sampling-from-Potts-Models","page":"Sampling","title":"Sampling from Potts Models","text":"The mcmc_sample function allows you to sample sequences from a Potts model using Markov Chain Monte Carlo (MCMC) methods. This page provides an overview of the sampling process, including how to use the mcmc_sample function, its inputs, and outputs.  The docstring of mcmc_sample provides extra details. ","category":"section"},{"location":"sampling/#Overview","page":"Sampling","title":"Overview","text":"The mcmc_sample function supports different modes of sampling.\n\nChain: sample sequences along a Markov chain for a specified number of steps. \nTree: sample sequences along the branches of a phylogenetic tree.\nDiscrete: the evolutionary time corresponds to a discrete number of mcmc steps. \nContinuous: the evolutionary time corresponds to a continuous time markov chain, as in many phylogenetics methods. \n\nIt is of course possible to mix modes (1,2) with (3,4).  The sampling process is controlled by the  structure SamplingParameters, which allows you to customize the behavior of the MCMC algorithm.\n\n","category":"section"},{"location":"sampling/#Chain-Sampling","page":"Sampling","title":"Chain Sampling","text":"Start an evolutionary trajectory, i.e. a montecarlo chain, which is sampled at specified times.  The code below samples M=5 sequences, each separated by 50 discrete Gibbs steps. \n\nL, q, M = 20, 21, 5; # sequence of lenth 20, 21 amino acids, 5 samples\ng = PottsGraph(L, q, Float64; init=:rand); # random graph\nparams = SamplingParameters(; sampling_type=:discrete, Teq=50, burnin=100)\ninitial_sequence = AASequence(L)\nresult = mcmc_sample(g, M, params; init=initial_sequence);\n\nThe output is a named tuple with the following fields:\n\nsequences: an alignment or vector of sampled sequences.\ntvals: a vector with the number of steps at each sample.\ninfo: information about the run.\nparams: parameters used for the run as a Dict. \n\nresult.sequences # a BioSequenceMappings.Alignment\nwrite(\"/tmp/example.fasta\", result.sequences) # can be written to fasta format\nrun(`cat /tmp/example.fasta`) # headers correspond to the time of sampling\n\nThe burnin parameter means that 100 steps are performed before taking the first sample in the chain.  The first sequence of the chain is therefore different from initial_sequence: \n\njulia> AASequence(result.sequences[1]) != initial_sequence\ntrue\n\nIf we want to start the chain from a specific sequence, we just set burnin to 0.\n\njulia> params = SamplingParameters(; sampling_type=:discrete, Teq=50, burnin=0);\n\njulia> result = mcmc_sample(g, M, params; init=initial_sequence);\n\njulia> AASequence(result.sequences[1]) == initial_sequence\ntrue\n\nIt is also possible to sample at non regularly spaced times by providing a vector of time values instead of the number M of sequences. \n\njulia> time_values = round.(Int, logrange(10, 1000, length=M)) # times at which the chain is sampled\n5-element Vector{Int64}:\n   10\n   32\n  100\n  316\n 1000\n\njulia> result = mcmc_sample(g, time_values, params; init=initial_sequence);\n\njulia> length(result.sequences)\n5\n\njulia> result.tvals == time_values\ntrue\n\njulia> result.sequences.names # sequence labels in the alignment correspond to sampling time\n5-element Vector{String}:\n \"10\"\n \"32\"\n \"100\"\n \"316\"\n \"1000\"\n\n","category":"section"},{"location":"sampling/#Tree-Sampling","page":"Sampling","title":"Tree Sampling","text":"Sampling along the branches of the tree is also done using mcmc_sample.  The input tree is provided either from a newick file, either as a TreeTools.Tree objet, see TreeTools. \n\nparams = SamplingParameters(; sampling_type=:discrete, Teq=50, burnin=0);\nresult = mcmc_sample(g, \"../../example/small_tree_integers.nwk\", params; init=initial_sequence);\nresult.tree # the tree object, with sequences stored at each node\nresult.tree.root.data.seq == initial_sequence # the initial sequence is placed at the root\n\nThe return value contains alignments of leaf and internal node sequences.  Sequences in the alignments are labeled according to the labels of the nodes in the input tree. If nodes are not labeled in the input tree, they are automatically assigned labels which can be read in the output tree. \n\nresult.internal_sequences\nresult.leaf_sequences\nresult.leaf_sequences.names\n\nAlternatively, sequences can be stored in dictionaries indexed by node labels: \n\nresult = mcmc_sample(\n    g, \"../../example/small_tree_integers.nwk\", params; \n    init=initial_sequence, alignment_output=false\n);\nresult.leaf_sequences\n\nIt is sometimes useful to perform sampling several times in a row.  This is done by calling mcmc_sample(graph, tree, M, params), where M is the number of repetitions.  In this case, it is can be practical to have all sequences sampled at a given node grouped in a single alignment, instead of having a list of alignments that each correspond to one tree.  This is achieved by calling PottsEvolver.pernode_alignment on the output of mcmc_sample:\n\nM = 5 # five repeats\nresult = mcmc_sample(\n    g, \"../../example/small_tree_integers.nwk\", M, params; init=initial_sequence\n);\nresult = PottsEvolver.pernode_alignment(result);\nresult.sequences[\"1\"] # all sequences sampled at node \"1\"","category":"section"},{"location":"sampling/#Interpreting-branch-lengths","page":"Sampling","title":"Interpreting branch lengths","text":"When sampling from a continuous time model, any real valued branch length is valid. Things get more complicated when sampling from a discrete model, where evolutionary time is measured in number of MCMC steps.  The BranchLengthMeaning type is used to facilitate this.  It is provided as a field of SamplingParameters. For instance\n\nSamplingParameters(; branchlength_meaning=BranchLengthMeaning(; type=:sweep, length=:exact))\n\nwill first multiply each branch in the tree by a factor L (length of the sequence), and expects the result to be exactly an integer. ","category":"section"},{"location":"sampling/#Continuous-time-sampling","page":"Sampling","title":"Continuous time sampling","text":"Discrete sampling is quite straightforward: the time corresponds to a discrete number of mcmc steps.  In continuous time however, it is customary to scale time so that the expected number of mutations per site per unit of time is 1.  This is done by setting the average_substitution_rate field of SamplingParameters, see Generative continuous time model reveals epistatic signatures in protein evolution. This average substituion rate can be computed either by sampling the potts model or by using an existing alignment of sequences. \n\nn_samples = 100 # compute the average transition rate from 100 samples\nTeq = 10*L; # discrete steps between samples\nstep_type = :glauber;\n\nΩ_1 = let \n    # first generate sample with discrete time, then use it to compute the average rate\n    s0 = AASequence(L)\n    params = SamplingParameters(; sampling_type=:discrete, Teq) \n    aln = mcmc_sample(g, M, params; init=s0).sequences\n    write(\"/tmp/tmp.fasta\", aln) # save the alignment for use below\n    aln = map(AASequence, aln)\n    # compute the average transition rate from the sampled alignment\n    PottsEvolver.average_transition_rate(g, step_type, aln)\nend\n\nΩ_2 = let\n    # Read the previously sampled alignment, stored in a fasta    \n    # Ω_1 == Ω_2\n    PottsEvolver.average_transition_rate(g, step_type, \"/tmp/tmp.fasta\")\nend\n\nΩ_3 = let\n    # call the average_transition_rate function directly, which will sample the potts model\n    s0 = AASequence(L)\n    PottsEvolver.average_transition_rate(g, step_type, s0; n_samples, Teq)\nend\n\nNow, define SamplingParameters(; sampling_type=:continuous, average_substitution_rate=Ω_1) to have a time-normalized MCMC. \n\n","category":"section"},{"location":"sampling/#Additional-Utilities","page":"Sampling","title":"Additional Utilities","text":"","category":"section"},{"location":"sampling/#Logging","page":"Sampling","title":"Logging","text":"You can control the verbosity of the sampling process using the verbose and logfile parameters:\n\nresult = mcmc_sample(g, 1000, params; init=:random_aa, verbose=1);","category":"section"},{"location":"genetic_code/#Using-the-genetic-code-during-sampling","page":"Genetic code","title":"Using the genetic code during sampling","text":"In construction... In brief, I use the algorithm of Emergent time scales of epistasis in protein evolution. ","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Documentation for PottsEvolver.\n\n","category":"section"},{"location":"reference/#PottsEvolver.mcmc_steps!","page":"Reference","title":"PottsEvolver.mcmc_steps!","text":"mcmc_steps!(\n    s::AbstractSequence, g, num_steps::Integer, p::SamplingParameters;\n    gibbs_holder, kwargs...\n)\n\nPerform num_steps discrete MCMC steps starting from sequence s and using graph g. The step type (:gibbs, :metropolis) and the interpretation of num_steps     (:changed, :accepted, :proposed) is set using p (see ?SamplingParameters). Modifies the input sequence s and returns it.\n\n\n\n\n\nmcmc_steps!(\n    sequence::AbstractSequence, g, Tmax::AbstractFloat, parameters::SamplingParameters;\n    kwargs...\n)\nmcmc_steps!(\n    state::CTMCState, g, Tmax::AbstractFloat, step_type::Symbol; kwargs...\n)\n\nSample g during time Tmax (continuous) from sequence seq. The step type is p.step_type (see ?SamplingParameters). Modifies the input sequence s and returns it. Allocates a CTMCState (three matrices of order q*L).\n\nNotes\n\nThe form with state::CTMCState will use a pre-allocated CTMCState for calculations.\nExpects parameters.sampling_type to be :continuous. Fails if otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PottsEvolver.aa_alphabet","page":"Reference","title":"PottsEvolver.aa_alphabet","text":"aa_alphabet\nnt_alphabet\ncodon_alphabet\n\nDefault alphabets for PottsEvolver.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PottsEvolver.codon_alphabet","page":"Reference","title":"PottsEvolver.codon_alphabet","text":"aa_alphabet\nnt_alphabet\ncodon_alphabet\n\nDefault alphabets for PottsEvolver.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PottsEvolver.nt_alphabet","page":"Reference","title":"PottsEvolver.nt_alphabet","text":"aa_alphabet\nnt_alphabet\ncodon_alphabet\n\nDefault alphabets for PottsEvolver.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#BioSequenceMappings.Alignment-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractSequence","page":"Reference","title":"BioSequenceMappings.Alignment","text":"Alignment(sequences; alphabet, names, as_codons=true)\n\nConstruct a BioSequenceMappings.Alignment from a set of sequences. If the sequences are AASequence, alphabet defaults to aa_alphabet. If they are CodonSequence, as_codons can be used to decide whether the alignment should store codons or amino acids. alphabet can be determined automatically from this.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.AASequence","page":"Reference","title":"PottsEvolver.AASequence","text":"mutable struct AASequence{T<:Integer} <: AbstractSequence\n\nField: seq::Vector{T}. Wrapper around a vector of integers, with implied alphabet PottsEvolver.aa_alphabet.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.AASequence-Tuple{Integer}","page":"Reference","title":"PottsEvolver.AASequence","text":"AASequence(L; T)\n\nReturn a random AASequence{T} of length L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.BranchLengthMeaning","page":"Reference","title":"PottsEvolver.BranchLengthMeaning","text":"BranchLengthMeaning\n\n    type::Symbol\n    length::Symbol\n\nDefine how the branch lengths should be interpreted when sampling on a tree with a discrete-time algorithm. This is done in two consecutive steps.\n\nDecide whether the branch length represents mcmc steps or sweeps.\nIf type==:sweep, multiply the branch length by the length of the sequence.\nElse, if type==:step, leave it as is.\nConvert the branch length to an integer value which will be the number of mcmc steps.\nif length==:exact, the branch length is expected to be an integer (rtol=1e-6).\nif length==:round, round it to the closest Int.\nif length==:poisson, sample a poisson distribution with the branch length as mean.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.CodonSequence-Tuple{Int64}","page":"Reference","title":"PottsEvolver.CodonSequence","text":"CodonSequence(L::Int; source=:aa, T)\n\nSample L states at random of the type of source (:aa or :codon):\n\nif :codon, sample codons at random\nif :aa, sample amino acids at random and reverse translate them randomly to matching codons\n\nUnderlying integer type is T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.CodonSequence-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"Reference","title":"PottsEvolver.CodonSequence","text":"CodonSequence(seq::Vector{Integer}; source=:aa)\n\nBuild a CodonSequence from seq:\n\nif source==:codon, seq is interpreted as representing codons (see codon_alphabet);\nif source==:aa, seq is interpreted as representing amino acids (see aa_alphabet); matching codons are randomly chosen using the PottsEvolver.reverse_code_rand method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.NumSequence","page":"Reference","title":"PottsEvolver.NumSequence","text":"NumSequence{T<:Integer, q}\n\nA mutable struct representing a sequence of integers with a maximum value constraint q.\n\nExplicit Construction: NumSequence(seq::AbstractVector{T}, q::Integer) or NumSequence{T,q}(seq)\nRandom Construction: NumSequence{T,q}(L::Integer) or NumSequence(L::Integer, q::Integer; T=IntType).  Construct a NumSequence of length L with random integers of type T in the range [1, q].\n\nExamples\n\njulia> seq = [1, 2, 3, 4]\njulia> num_seq = NumSequence(seq, 4)\n\njulia> random_seq = NumSequence(10, 5; T=Int8)\n\n\njulia> max_value = num_seq.q  # Returns 4\n\n\njulia> copied_seq = copy(num_seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.PottsGraph","page":"Reference","title":"PottsEvolver.PottsGraph","text":"PottsGraph(L, q[, T]; init = :null, alphabet)\n\nReturn a PottsGraph{T} of the required size.\n\ninit == :null: parameters are intialized to zero.\ninit == :rand: parameters are randomly sampled using Jrand and hrand keywords.\n\nalphabet is aa_alphabet if q=21, nothing otherwise.\n\nRandom initialization\n\nhrand should be a function q -> h.\nJrand should be a function q -> J.\n\nJrand does not have to return a symetric matrix. The output matrix is made symetric with zeroes on the diagonal blocks.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.PottsGraph-2","page":"Reference","title":"PottsEvolver.PottsGraph","text":"PottsGraph{T}\n\nArray J of dimensions q x q x L x L and eltype T\nArray h of dimensions q x L and eltype T\nInverse temperature β\nalphabet\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.SamplingParameters","page":"Reference","title":"PottsEvolver.SamplingParameters","text":"mutable struct SamplingParameters\n\nConstruct using keyword arguments:\n\nsampling_type::Symbol = :discrete\nstep_type::Symbol = :gibbs\nTeq::Real = 0 # time between samples, for chain\nburnin::Real = 5*Teq # time before first sample\nstep_meaning::Symbol = :accepted # relevant for :discrete\nfraction_gap_step::Float64 = 0.9 # relevant for :discrete and codon sampling\nbranchlength_meaning::BranchLengthMeaning # relevant for :discrete and sampling on a tree\nsubstitution_rate::Union{Nothing,Float64} = nothing # relevant for :continuous\ntrack_substitutions::Bool = false # relevant for continuous\n\nsampling_type can be :discrete or :continuous. The time between samples is Teq, and an extra time burnin is taken before the first sample. Allowed values of step_type differ between the continuous and discrete cases.\n\nDiscrete sampling\n\nTeq is measured in swaps: accepted (or attempted) changes of one sequence position. It must be an integer.\nburnin: number of steps starting from the initial sequence before the first sample. Must be an integer.\nstep_type: :gibbs only. I intend to implement :metropolis and maybe :glauber.\nstep_meaning (:discrete only): whether a swap count towards equilibration or not. It can take three values\n:proposed: all mcmc steps count towards equilibration\n:accepted: only accepted steps count (all steps for non-codon Gibbs)\n:changed: only steps that lead to a change count (Gibbs can resample the same state)\nNote: Gibbs steps for codons are more complicated, since they involve the possibility   Metropolis step for gaps, which can be rejected.\nfraction_gap_step: fraction of :metropolis steps concerning gaps when sampling with codons. This is only relevant for discrete sampling with codons.\nbranchlength_meaning: how branch-lengths on a tree must be converted to swaps.   See ?BranchLengthMeaning for information.   This is only useful if you sample along branches of a tree.\n\nContinuous sampling\n\nFor continuous sampling, there is no notion of swap/sweep or of accepted/rejected steps. Since any positive real number is acceptable as a sampling time, branch lenghts of trees can be used directly.\n\nTeq and burnin are floats.\nstep_type can be :metropolis, :glauber or :sqrt.\nsubstitution_rate is the average substitution rate for a given Potts model (the average runs over sequences). It is the result of average_substitution_rate. This is computed automatically if not provided (but takes some time).\ntrack_substitutions: track all substitutions (position, state, time) occuring during the Gillespie simulation. They are returned in the info output of mcmc_sample.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.average_transition_rate-Tuple{PottsGraph, Any, AbstractSequence}","page":"Reference","title":"PottsEvolver.average_transition_rate","text":"average_transition_rate(g::PottsGraph, step_type, s0::AbstractSequence)\naverage_transition_rate(g::PottsGraph, step_type, S::Vector{<:AbstractSequence})\naverage_transition_rate(\n    g::PottsGraph, step_type, fastafile::AbstractString; seq_type=AASequence\n)\n\nCompute the average transition rate for the continuous time Markov chain based on g.     A sample from g is generated using a discrete time Markov chain for this purpose.\n\nIn the first form, a sample from g is used for averaging. s0 is only used to initialize the CTMCState and provide a type (codon or aa), and the keyword arguments are used to parametrize the sampling process.\n\nIn the second form, the sample is provided as argument, either as a vector of sequences or as a fasta file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.energy-Tuple{AbstractVector{<:Integer}, PottsGraph}","page":"Reference","title":"PottsEvolver.energy","text":"energy(s, g::PottsGraph)\n\nEnergy of sequence s in g.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.genetic_code-Tuple{PottsEvolver.Codon}","page":"Reference","title":"PottsEvolver.genetic_code","text":"genetic_code(c::Codon)\n\nTranslate c and return the amino acid as a Char.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.genetic_code-Tuple{T} where T<:Integer","page":"Reference","title":"PottsEvolver.genetic_code","text":"genetic_code(x::Integer)\n\nTranslate the ith codon and return the index of the corresponding amino acid, using the default aa_alphabet\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.mcmc_sample","page":"Reference","title":"PottsEvolver.mcmc_sample","text":"mcmc_sample(\n    g::PottsGraph, M::Integer, s0::AbstractSequence, params::SamplingParameters;\n    rng=Random.GLOBAL_RNG, verbose=0, progress_meter=true, alignment_output=true,\n)\nmcmc_sample(\n    g::PottsGraph, M::Integer, params::SamplingParameters; init=:random_num, kwargs...)\n)\nmcmc_sample(g, tvals::AbstractVector, s0, params::SamplingParameters; kwargs...)\n\nFirst form: sample g for M steps starting from s0, using parameters in params. Return value: named tuple with fields\n\nsequences: alignment (or vector) of sequences\ntvals: vector with the number of steps at each sample\ninfo: information about the run\nparams: parameters of the run.\n\nSecond form: same, but initial sequence is provided through the init kwarg.\n\nThird form: provide a set of times tvals at which samples are taken. Can also be used with the init kwarg.\n\nNote: this function is not very efficient if M is small.\n\nSampling details are determined by parameters, see ?SamplingParameters. Whether to use the genetic code is determined by the type of the init sequence: it is used if init::CodonSequence, otherwise not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PottsEvolver.mcmc_sample-Tuple{Any, TreeTools.Tree, Any}","page":"Reference","title":"PottsEvolver.mcmc_sample","text":"mcmc_sample(g, tree, M=1, params; alignment_output, translate_output, init, kwargs...)\n\nSample g along branches of tree. Repeat the process M times, returning an array of named tuples of the form   (; tree, leaf_sequences, internal_sequences). If M is omitted, the output is just a named tuple (no array). Sequences in leaf_sequences and internal_sequences are sorted in post-order traversal.\n\nThe sequence to be used as the root should be provided using the init kwarg,   see ?PottsEvolver.get_init_sequence.\n\nIf alignment_output, the sequences will be wrapped into an Alignment structure. Otherwise, they are in a dictionary indexed by node label. If translate_output and if the root sequence was a CodonSequence, the output alignment will contain the amino acid sequence and not the codons.\n\nWarning\n\nThe Teq field of params is not used in the sampling. However, the burnin field will be used to set the root sequence: burnin mcmc steps will be performed starting from the input sequence, and the result is placed at the root. If you want a precise root sequence to be used, set burnin=0 in params.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.read_graph","page":"Reference","title":"PottsEvolver.read_graph","text":"read_graph\nread_potts_graph\n\nRead PottsGraph object from a file.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PottsEvolver.read_potts_graph","page":"Reference","title":"PottsEvolver.read_potts_graph","text":"read_potts_graph\n\nAlias for read_graph.\n\n\n\n\n\n","category":"function"},{"location":"#PottsEvolver","page":"Index","title":"PottsEvolver","text":"Documentation for PottsEvolver. In construction. \n\nusing Pkg\nPkg.add(\"PottsEvolver\")\nusing PottsEvolver\n\nSimulate evolution of protein sequences (or other) using a Potts model. \n\nDiscrete or continuous time sampling.\nSample single MCMC chains, or along branches of a tree.\nSampling can take the genetic code into account. \n\nNote: the package relies on two personal packages\n\nTreeTools.jl to handle phylogenetic trees\nBioSequenceMappings.jl to handle sequence alignments and to convert amino acids to digits.\n\nRemaining issues: \n\nsampling not reproducible when picking a random seed.\nuse of Alphabet not clear: it's part of the PottsGraph, but only the default alphabets can really be used. ","category":"section"},{"location":"pottsgraph/#PottsGraph","page":"Potts model","title":"PottsGraph","text":"The PottsGraph structure represents a Potts model, a statistical model used to describe interactions in a system with multiple states (e.g., amino acids in a protein sequence). It is defined by the following fields:\n\nJ: A 4-dimensional array of dimensions q x q x L x L representing the coupling parameters between states at different positions.\nh: A 2-dimensional array of dimensions q x L representing the local field parameters for each state at each position.\nβ: The inverse temperature parameter, used during sampling. \nalphabet: An optional Alphabet object to map states to characters (e.g., amino acids), see the BioSequenceMappings.jl package.\n\nq represents the number of states (e.g., 21 for amino acids + gap), and L is the length of the sequence.","category":"section"},{"location":"pottsgraph/#Structure-and-Fields","page":"Potts model","title":"Structure and Fields","text":"The PottsGraph is defined as follows:\n\n@kwdef mutable struct PottsGraph{T<:AbstractFloat}\n    J::Array{T,4}\n    h::Array{T,2}\n    β::T = 1.0\n    alphabet::Union{Nothing, BioAequenceMappings.Alphabet{Char,<:Integer}} = aa_alphabet\nend","category":"section"},{"location":"pottsgraph/#Creating-a-PottsGraph","page":"Potts model","title":"Creating a PottsGraph","text":"You can create a PottsGraph with null or random initialization:\n\nusing PottsEvolver\nL, q = (10, 21);\ng_null = PottsGraph(L, q, Float64; init=:null); # null initialization\ng_null.J[:, :, 1, 2]\ng_rand = PottsGraph(L, q, Float64; init=:rand); # random initialization\nsize(g_rand)\ng_rand.J[:, :, 1, 2] # coupling matrix between sites 1 and 2\n\nIt is sometimes easier to view the couplings J as a square matrix. \n\njulia> J_matrix = PottsEvolver.couplings_as_matrix(g_rand.J);\n\njulia> size(J_matrix) # (L*q x L*q)\n(420, 420)\n\njulia> J_matrix ≈ J_matrix' # The coupling matrix should be symetric\ntrue\n\njulia> J_tensor = PottsEvolver.matrix_as_couplings(J_matrix, L, q); # back to tensor\n\njulia> J_tensor ≈ g_rand.J\ntrue\n\nnote: Note\nThere is no check that the coupling matrix is symetric, although it should normally be the case for Potts models. ","category":"section"},{"location":"pottsgraph/#Reading-and-writing-PottsGraph","page":"Potts model","title":"Reading and writing PottsGraph","text":"","category":"section"},{"location":"pottsgraph/#Reading-from-a-File","page":"Potts model","title":"Reading from a File","text":"The read_graph function reads a PottsGraph from a file. The file should follow the format \n\nJ i j a b value # coupling lines\n...\nh i a value # field lines\n\nwhere i and j are sequence positions and a, b are integer states (e.g. representing amino acids). \n\n# Read the graph in the example folder\ng = read_graph(\"../../example/toy_potts.dat)","category":"section"},{"location":"pottsgraph/#Writing-to-a-File","page":"Potts model","title":"Writing to a File","text":"The write function writes the parameters of a PottsGraph to a file.\n\nwrite(\"path/to/output.txt\", g; sigdigits=5, index_style=1)","category":"section"},{"location":"pottsgraph/#Basic-Functions","page":"Potts model","title":"Basic Functions","text":"","category":"section"},{"location":"pottsgraph/#Energy-of-a-Sequence","page":"Potts model","title":"Energy of a Sequence","text":"The energy function calculates the statistical energy of a sequence. \n\nseq = AASequence(map(aa_alphabet, collect(\"ACDEFGHIKLMNPQRSTVWY\")))\nE = energy(seq, g_rand)","category":"section"},{"location":"pottsgraph/#Gauge-Change","page":"Potts model","title":"Gauge Change","text":"The set_gauge! function allows you to change the gauge of the PottsGraph. Supported gauges include :zero_sum and :lattice_gas.\n\njulia> PottsEvolver.set_gauge!(g_rand, :zero_sum);\n\njulia> all(≈(0; atol=1e-14), sum(g_rand.h, dims=1)) # sum of h values along each sequence position is zero\ntrue\n\njulia> all(≈(0; atol=1e-14), sum(g_rand.J, dims=[1,2])) #same goes for J\ntrue","category":"section"},{"location":"pottsgraph/#Additional-Utilities","page":"Potts model","title":"Additional Utilities","text":"","category":"section"},{"location":"pottsgraph/#Profile-Model","page":"Potts model","title":"Profile Model","text":"The profile_model function creates a PottsGraph with only fields that fit the single-site frequencies in a given matrix.\n\njulia> f1 = rand(21, 10);  # Example frequency matrix - does not have to be normalized\n\njulia> profile = PottsEvolver.profile_model(f1; pc=1e-2);\n\njulia> all(≈(0; atol=1e-14), profile.J)\ntrue","category":"section"}]
}
