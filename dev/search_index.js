var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"Documentation for PottsEvolver.\n\n","category":"section"},{"location":"reference/#PottsEvolver.mcmc_steps!","page":"Reference","title":"PottsEvolver.mcmc_steps!","text":"mcmc_steps!(\n    s::AbstractSequence, g, num_steps::Integer, p::SamplingParameters;\n    gibbs_holder, kwargs...\n)\n\nPerform num_steps discrete MCMC steps starting from sequence s and using graph g. The step type (:gibbs, :metropolis) and the interpretation of num_steps     (:changed, :accepted, :proposed) is set using p (see ?SamplingParameters). Modifies the input sequence s and returns it.\n\n\n\n\n\nmcmc_steps!(\n    sequence::AbstractSequence, g, Tmax::AbstractFloat, parameters::SamplingParameters; \n    kwargs...\n)\nmcmc_steps!(\n    state::CTMCState, g, Tmax::AbstractFloat, step_type::Symbol; kwargs...\n)\n\nSample g during time Tmax (continuous) from sequence seq. The step type is p.step_type (see ?SamplingParameters). Modifies the input sequence s and returns it. Allocates a CTMCState (three matrices of order q*L).\n\nNotes\n\nThe form with state::CTMCState will use a pre-allocated CTMCState for calculations. \nExpects parameters.sampling_type to be :continuous. Fails if otherwise. \n\n\n\n\n\n","category":"function"},{"location":"reference/#PottsEvolver.aa_alphabet","page":"Reference","title":"PottsEvolver.aa_alphabet","text":"aa_alphabet\nnt_alphabet\ncodon_alphabet\n\nDefault alphabets for PottsEvolver.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PottsEvolver.codon_alphabet","page":"Reference","title":"PottsEvolver.codon_alphabet","text":"aa_alphabet\nnt_alphabet\ncodon_alphabet\n\nDefault alphabets for PottsEvolver.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#PottsEvolver.nt_alphabet","page":"Reference","title":"PottsEvolver.nt_alphabet","text":"aa_alphabet\nnt_alphabet\ncodon_alphabet\n\nDefault alphabets for PottsEvolver.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#BioSequenceMappings.Alignment-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractSequence","page":"Reference","title":"BioSequenceMappings.Alignment","text":"Alignment(sequences; alphabet, names, as_codons=true)\n\nConstruct a BioSequenceMappings.Alignment from a set of sequences. If the sequences are AASequence, alphabet defaults to aa_alphabet. If they are CodonSequence, as_codons can be used to decide whether the alignment should store codons or amino acids. alphabet can be determined automatically from this.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.AASequence","page":"Reference","title":"PottsEvolver.AASequence","text":"mutable struct AASequence{T<:Integer} <: AbstractSequence\n\nField: seq::Vector{T}. Wrapper around a vector of integers, with implied alphabet PottsEvolver.aa_alphabet.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.AASequence-Tuple{Integer}","page":"Reference","title":"PottsEvolver.AASequence","text":"AASequence(L; T)\n\nReturn a random AASequence{T} of length L.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.BranchLengthMeaning","page":"Reference","title":"PottsEvolver.BranchLengthMeaning","text":"BranchLengthMeaning\n\n    type::Symbol\n    length::Symbol\n\nDefine how the branch lengths should be interpreted when sampling on a tree. This is done in two consecutive steps.\n\nConvert the branch lengths to mcmc steps.  If type==:sweep, multiply the branch length by the length of the sequence.  Else, if type==:step, leave it as is.\nConvert the branch length to an integer value which will be the number of mcmc steps.\n\nif length==:exact, the branch length is expected to be an integer (rtol=1e-6).\nif length==:round, round it to the closest Int.\nif length==:poisson, sample a poisson distribution with the branch length as mean.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.CodonSequence-Tuple{Int64}","page":"Reference","title":"PottsEvolver.CodonSequence","text":"CodonSequence(L::Int; source=:aa, T)\n\nSample L states at random of the type of source (:aa or :codon):\n\nif :codon, sample codons at random\nif :aa, sample amino acids at random and reverse translate them randomly to matching codons\n\nUnderlying integer type is T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.CodonSequence-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Integer","page":"Reference","title":"PottsEvolver.CodonSequence","text":"CodonSequence(seq::Vector{Integer}; source=:aa)\n\nBuild a CodonSequence from seq:\n\nif source==:codon, seq is interpreted as representing codons (see codon_alphabet);\nif source==:aa, seq is interpreted as representing amino acids (see aa_alphabet); matching codons are randomly chosen using the PottsEvolver.reverse_code_rand method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.NumSequence","page":"Reference","title":"PottsEvolver.NumSequence","text":"NumSequence{T<:Integer, q}\n\nA mutable struct representing a sequence of integers with a maximum value constraint q.\n\nExplicit Construction: NumSequence(seq::AbstractVector{T}, q::Integer) or NumSequence{T,q}(seq)\nRandom Construction: NumSequence{T,q}(L::Integer) or NumSequence(L::Integer, q::Integer; T=IntType).  Construct a NumSequence of length L with random integers of type T in the range [1, q].\n\nExamples\n\njulia> seq = [1, 2, 3, 4]\njulia> num_seq = NumSequence(seq, 4)\n\njulia> random_seq = NumSequence(10, 5; T=Int8)\n\n\njulia> max_value = num_seq.q  # Returns 4\n\n\njulia> copied_seq = copy(num_seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.PottsGraph","page":"Reference","title":"PottsEvolver.PottsGraph","text":"PottsGraph(L, q[, T]; init = :null, alphabet)\n\nReturn a PottsGraph{T} of the required size.\n\ninit == :null: parameters are intialized to zero.\ninit == :rand: parameters are randomly sampled using Jrand and hrand keywords.\n\nalphabet is aa_alphabet if q=21, nothing otherwise.\n\nRandom initialization\n\nhrand should be a function q -> h.\nJrand should be a function q -> J.\n\nJrand does not have to return a symetric matrix. The output matrix is made symetric with zeroes on the diagonal blocks.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.PottsGraph-2","page":"Reference","title":"PottsEvolver.PottsGraph","text":"PottsGraph{T}\n\nArray J of dimensions q x q x L x L and eltype T\nArray h of dimensions q x L and eltype T\nInverse temperature Î²\nalphabet\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.SamplingParameters","page":"Reference","title":"PottsEvolver.SamplingParameters","text":"mutable struct SamplingParameters\n\nConstruct using keyword arguments:\n\nsampling_type::Symbol = :discrete\nstep_type::Symbol = :gibbs\nTeq::Real = 0 # time between samples, for chain\nburnin::Real = 5*Teq # time before first sample\nstep_meaning::Symbol = :accepted # relevant for :discrete\nfraction_gap_step::Float64 = 0.9 # relevant for :discrete and codon sampling\nbranchlength_meaning::BranchLengthMeaning # relevant for :discrete and sampling on a tree\nsubstitution_rate::Union{Nothing,Float64} = nothing # relevant for :continuous\ntrack_substitutions::Bool = false # relevant for continuous\n\nsampling_type can be :discrete or :continuous. The time between samples is Teq, and an extra time burnin is taken before the first sample. Allowed values of step_type differ between the continuous and discrete cases.\n\nDiscrete sampling\n\nTeq is measured in swaps: accepted (or attempted) changes of one sequence position. It must be an integer.\nburnin: number of steps starting from the initial sequence before the first sample. Must be an integer.\nstep_type: :gibbs only. I intend to implement :metropolis and maybe :glauber.\nstep_meaning (:discrete only): whether a swap count towards equilibration or not. It can take three values\n:proposed: all mcmc steps count towards equilibration\n:accepted: only accepted steps count (all steps for non-codon Gibbs)\n:changed: only steps that lead to a change count (Gibbs can resample the same state)\nNote: Gibbs steps for codons are more complicated, since they involve the possibility   Metropolis step for gaps, which can be rejected.\nfraction_gap_step: fraction of :metropolis steps concerning gaps when sampling with codons. This is only relevant for discrete sampling with codons.\nbranchlength_meaning: how branch-lengths on a tree must be converted to swaps.   See ?BranchLengthMeaning for information.   This is only useful if you sample along branches of a tree.\n\nContinuous sampling\n\nFor continuous sampling, there is no notion of swap/sweep or of accepted/rejected steps. Since any positive real number is acceptable as a sampling time, branch lenghts of trees can be used directly.\n\nTeq and burnin are floats.\nstep_type can be :metropolis, :glauber or :sqrt.\nsubstitution_rate is the average substitution rate for a given Potts model (the average runs over sequences). It is the result of average_substitution_rate. This is computed automatically if not provided (but takes some time).\ntrack_substitutions: track all substitutions (position, state, time) occuring during the Gillespie simulation. They are returned in the info output of mcmc_sample.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PottsEvolver.energy-Tuple{AbstractVector{<:Integer}, PottsGraph}","page":"Reference","title":"PottsEvolver.energy","text":"energy(s, g::PottsGraph)\n\nEnergy of sequence s in g.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.genetic_code-Tuple{PottsEvolver.Codon}","page":"Reference","title":"PottsEvolver.genetic_code","text":"genetic_code(c::Codon)\n\nTranslate c and return the amino acid as a Char.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.genetic_code-Tuple{T} where T<:Integer","page":"Reference","title":"PottsEvolver.genetic_code","text":"genetic_code(x::Integer)\n\nTranslate the ith codon and return the index of the corresponding amino acid, using the default aa_alphabet\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.mcmc_sample","page":"Reference","title":"PottsEvolver.mcmc_sample","text":"mcmc_sample(\n    g::PottsGraph, M::Integer, s0::AbstractSequence, params::SamplingParameters;\n    rng=Random.GLOBAL_RNG, verbose=0, progress_meter=true, alignment_output=true,\n)\nmcmc_sample(\n    g::PottsGraph, M::Integer, params::SamplingParameters; init=:random_num, kwargs...)\n)\nmcmc_sample(g, tvals::AbstractVector, s0, params::SamplingParameters; kwargs...)\n\nFirst form: sample g for M steps starting from s0, using parameters in params. Return value: named tuple with fields\n\nsequences: alignment (or vector) of sequences\ntvals: vector with the number of steps at each sample\ninfo: information about the run\nparams: parameters of the run.\n\nSecond form: same, but initial sequence is provided through the init kwarg.\n\nThird form: provide a set of times tvals at which samples are taken. Can also be used with the init kwarg.\n\nNote: this function is not very efficient if M is small.\n\nSampling details are determined by parameters, see ?SamplingParameters. Whether to use the genetic code is determined by the type of the init sequence: it is used if init::CodonSequence, otherwise not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PottsEvolver.mcmc_sample-Tuple{Any, TreeTools.Tree, Any}","page":"Reference","title":"PottsEvolver.mcmc_sample","text":"mcmc_sample(g, tree, M=1, params; alignment_output, translate_output, init, kwargs...)\n\nSample g along branches of tree. Repeat the process M times, returning an array of named tuples of the form   (; tree, leaf_sequences, internal_sequences). If M is omitted, the output is just a named tuple (no array). Sequences in leaf_sequences and internal_sequences are sorted in post-order traversal.\n\nThe sequence to be used as the root should be provided using the init kwarg,   see ?PottsEvolver.get_init_sequence.\n\nIf alignment_output, the sequences will be wrapped into an Alignment structure. Otherwise, they are in a dictionary indexed by node label. If translate_output and if the root sequence was a CodonSequence, the output alignment will contain the amino acid sequence and not the codons.\n\nWarning\n\nThe Teq field of params is not used in the sampling. However, the burnin field will be used to set the root sequence: burnin mcmc steps will be performed starting from the input sequence, and the result is placed at the root. If you want a precise root sequence to be used, set burnin=0 in params.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PottsEvolver.read_graph","page":"Reference","title":"PottsEvolver.read_graph","text":"read_graph\nread_potts_graph\n\nRead PottsGraph object from a file.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PottsEvolver.read_potts_graph","page":"Reference","title":"PottsEvolver.read_potts_graph","text":"read_potts_graph\n\nAlias for read_graph.\n\n\n\n\n\n","category":"function"},{"location":"#PottsEvolver","page":"Quickstart","title":"PottsEvolver","text":"","category":"section"}]
}
